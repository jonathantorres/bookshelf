*8.4 - The longest common subsequence (LCS) of two sequences `T` and `P` is the longest sequence `L` such that `L` is a subsequence of both `T` and `P`. The shortest common supersequence (SCS) of `T` and `P` is the smallest sequence `L` such that both `T` and `P` are a subsequence of `L`*
- *Give efficient algorithms to find the LCS and SCS of two given sequences.*
- *Let `d(T,P)` be the minimum edit distance between `T` and `P` when no substitutions are allowed (the only changes are character insertion and deletion). Prove that `d(T,P)=|SCS(T,P)| âˆ’ |LCS(T,P)|` where `|SCS(T,P)|(|LCS(T,P)|)` is the size of the shortest SCS (longest LCS) of `T` and `P`*
***
- LCS: Let `M[i,j]` denote the number of characters in the longest commmon substring of `S[1]...S[i]` and `T[1]...T[j]`. When `S[i] != T[j]`, there is no way the last pair of characters could match, so `M[i,j] = max(M[i,j-1], M[i-1, j])`. But if `S[i] = T[j]` we have the option to select this character for our substring, so `M[i,j] = max(M[i-1, j-1]+1, M[i-1,j], M[i, j-1])`. This computes the length of the longest common subsequence in `O(nm)` time.
- SCS: This can be easily reduced to TSP. Create an overlap graph `G` where vertex `v` represents string `S[i]`. Assign edge `(v[i], v[j])` weight equal to the length of `S[i]` minus the overlap of `S[j]` with `S[i]`. Thus, `w(v[i]. v[j]) = 1` for `S[i] = abc` and `S[j] = bed`. The minimum weight path visiting all the vertices defines the shortest common substring. The edge weights are not symmetric.
